/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package Orb.Orb.models.operations;

import Orb.Orb.utils.DateTimeDeserializer;
import Orb.Orb.utils.DateTimeSerializer;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import java.time.OffsetDateTime;

public class CreateBackfillRequestBody {
    /**
     * The time at which no more events will be accepted for this backfill. The backfill will automatically begin reflecting throughout Orb at the close time. If not specified, it will default to 1 day after the creation of the backfill.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("close_time")
    public OffsetDateTime closeTime;

    public CreateBackfillRequestBody withCloseTime(OffsetDateTime closeTime) {
        this.closeTime = closeTime;
        return this;
    }
    
    /**
     * The ID of the customer to which this backfill is scoped.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customer_id")
    public String customerId;

    public CreateBackfillRequestBody withCustomerId(String customerId) {
        this.customerId = customerId;
        return this;
    }
    
    /**
     * The external customer ID of the customer to which this backfill is scoped.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("external_customer_id")
    public String externalCustomerId;

    public CreateBackfillRequestBody withExternalCustomerId(String externalCustomerId) {
        this.externalCustomerId = externalCustomerId;
        return this;
    }
    
    /**
     * If true, replaces all existing events in the timeframe with the newly ingested events. If false, adds the newly ingested events to the existing events.
     */
    @JsonProperty("replace_existing_events")
    public Boolean replaceExistingEvents;

    public CreateBackfillRequestBody withReplaceExistingEvents(Boolean replaceExistingEvents) {
        this.replaceExistingEvents = replaceExistingEvents;
        return this;
    }
    
    /**
     * The (exclusive) end of the usage timeframe affected by this backfill.
     */
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("timeframe_end")
    public OffsetDateTime timeframeEnd;

    public CreateBackfillRequestBody withTimeframeEnd(OffsetDateTime timeframeEnd) {
        this.timeframeEnd = timeframeEnd;
        return this;
    }
    
    /**
     * The (inclusive) end of the usage timeframe affected by this backfill.
     */
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("timeframe_start")
    public OffsetDateTime timeframeStart;

    public CreateBackfillRequestBody withTimeframeStart(OffsetDateTime timeframeStart) {
        this.timeframeStart = timeframeStart;
        return this;
    }
    
    public CreateBackfillRequestBody(@JsonProperty("replace_existing_events") Boolean replaceExistingEvents, @JsonProperty("timeframe_end") OffsetDateTime timeframeEnd, @JsonProperty("timeframe_start") OffsetDateTime timeframeStart) {
        this.replaceExistingEvents = replaceExistingEvents;
        this.timeframeEnd = timeframeEnd;
        this.timeframeStart = timeframeStart;
  }
}
