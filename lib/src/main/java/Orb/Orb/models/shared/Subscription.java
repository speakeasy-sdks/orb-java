/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package Orb.Orb.models.shared;

import Orb.Orb.utils.DateTimeDeserializer;
import Orb.Orb.utils.DateTimeSerializer;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import java.time.OffsetDateTime;

/**
 * Subscription - A subscription represents the purchase of a plan by a customer.
 * 
 * By default, subscriptions begin on the day that they're created and renew automatically for each billing cycle at the cadence that's configured in the plan definition.
 * 
 * Subscriptions also default to **beginning of month alignment**, which means the first invoice issued for the subscription will have pro-rated charges between the `start_date` and the first of the following month. Subsequent billing periods will always start and end on a month boundary (e.g. subsequent month starts for monthly billing).
 * 
 * Depending on the plan configuration, any _flat_ recurring fees will be billed either at the beginning (in-advance) or end (in-arrears) of each billing cycle. Plans default to **in-advance billing**. Usage-based fees are billed in arrears as usage is accumulated. In the normal course of events, you can expect an invoice to contain usage-based charges for the previous period, and a recurring fee for the following period.
 */
public class Subscription {
    /**
     * The current plan phase that is active, only if the subscription's plan has phases.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("active_plan_phase_order")
    public Double activePlanPhaseOrder;

    public Subscription withActivePlanPhaseOrder(Double activePlanPhaseOrder) {
        this.activePlanPhaseOrder = activePlanPhaseOrder;
        return this;
    }
    
    /**
     * Determines whether issued invoices for this subscription will automatically be charged with the saved payment method on the due date. This property defaults to the plan's behavior.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("auto_collection")
    public Boolean autoCollection;

    public Subscription withAutoCollection(Boolean autoCollection) {
        this.autoCollection = autoCollection;
        return this;
    }
    
    /**
     * The day of the month on which the billing cycle is anchored. If the maximum number of days in a month is greater than this value, the last day of the month is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing period begins on the 30th.
     */
    @JsonProperty("billing_cycle_day")
    public Double billingCycleDay;

    public Subscription withBillingCycleDay(Double billingCycleDay) {
        this.billingCycleDay = billingCycleDay;
        return this;
    }
    
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("created_at")
    public OffsetDateTime createdAt;

    public Subscription withCreatedAt(OffsetDateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    /**
     * The end of the current billing period. This is an exclusive timestamp, such that the instant returned is not part of the billing period. Set to null for subscriptions that are not currently active.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("current_billing_period_end_date")
    public OffsetDateTime currentBillingPeriodEndDate;

    public Subscription withCurrentBillingPeriodEndDate(OffsetDateTime currentBillingPeriodEndDate) {
        this.currentBillingPeriodEndDate = currentBillingPeriodEndDate;
        return this;
    }
    
    /**
     * The start of the current billing period. This is an inclusive timestamp; the instant returned is exactly the beginning of the billing period. Set to null if the subscription is not currently active.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("current_billing_period_start_date")
    public OffsetDateTime currentBillingPeriodStartDate;

    public Subscription withCurrentBillingPeriodStartDate(OffsetDateTime currentBillingPeriodStartDate) {
        this.currentBillingPeriodStartDate = currentBillingPeriodStartDate;
        return this;
    }
    
    /**
     * A customer is a buyer of your products, and the other party to the billing relationship.
     * 
     * In Orb, customers are assigned system generated identifiers automatically, but it's often desirable to have these match existing identifiers in your system. To avoid having to denormalize Orb ID information, you can pass in an `external_customer_id` with your own identifier. See [Customer ID Aliases](../guides/events-and-metrics/customer-aliases) for further information about how these aliases work in Orb.
     * 
     * In addition to having an identifier in your system, a customer may exist in a payment provider solution like Stripe. Use the `payment_provider_id` and the `payment_provider` enum field to express this mapping.
     * 
     * A customer also has a timezone (from the standard [IANA timezone database](https://www.iana.org/time-zones)), which defaults to your account's timezone. See [Timezone localization](../guides/product-catalog/) for information on what this timezone parameter influences within Orb.
     */
    @JsonProperty("customer")
    public Customer customer;

    public Subscription withCustomer(Customer customer) {
        this.customer = customer;
        return this;
    }
    
    /**
     * Determines the default memo on this subscriptions' invoices. Note that if this is not provided, it is determined by the plan configuration.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("default_invoice_memo")
    public String defaultInvoiceMemo;

    public Subscription withDefaultInvoiceMemo(String defaultInvoiceMemo) {
        this.defaultInvoiceMemo = defaultInvoiceMemo;
        return this;
    }
    
    /**
     * The date Orb stops billing for this subscription.
     */
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("end_date")
    public OffsetDateTime endDate;

    public Subscription withEndDate(OffsetDateTime endDate) {
        this.endDate = endDate;
        return this;
    }
    
    /**
     * List of all fixed fee quantities associated with this subscription, with their start and end dates. This list contains the initial quantity along with quantity changes.
     */
    @JsonProperty("fixed_fee_quantity_schedule")
    public SubscriptionFixedFeeQuantitySchedule[] fixedFeeQuantitySchedule;

    public Subscription withFixedFeeQuantitySchedule(SubscriptionFixedFeeQuantitySchedule[] fixedFeeQuantitySchedule) {
        this.fixedFeeQuantitySchedule = fixedFeeQuantitySchedule;
        return this;
    }
    
    @JsonProperty("id")
    public String id;

    public Subscription withId(String id) {
        this.id = id;
        return this;
    }
    
    /**
     * User specified key-value pairs. If no metadata was specified at subscription creation time, this defaults to an empty dictionary.
     */
    @JsonProperty("metadata")
    public SubscriptionMetadata metadata;

    public Subscription withMetadata(SubscriptionMetadata metadata) {
        this.metadata = metadata;
        return this;
    }
    
    /**
     * Determines the difference between the invoice issue date for subscription invoices as the date that they are due. A value of "0" here represents that the invoice is due on issue, whereas a value of 30 represents that the customer has a month to pay the invoice.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("net_terms")
    public Long netTerms;

    public Subscription withNetTerms(Long netTerms) {
        this.netTerms = netTerms;
        return this;
    }
    
    @JsonProperty("plan")
    public Plan plan;

    public Subscription withPlan(Plan plan) {
        this.plan = plan;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("redeemed_coupon")
    public SubscriptionRedeemedCoupon redeemedCoupon;

    public Subscription withRedeemedCoupon(SubscriptionRedeemedCoupon redeemedCoupon) {
        this.redeemedCoupon = redeemedCoupon;
        return this;
    }
    
    /**
     * The date Orb starts billing for this subscription.
     */
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("start_date")
    public OffsetDateTime startDate;

    public Subscription withStartDate(OffsetDateTime startDate) {
        this.startDate = startDate;
        return this;
    }
    
    @JsonProperty("status")
    public SubscriptionStatus status;

    public Subscription withStatus(SubscriptionStatus status) {
        this.status = status;
        return this;
    }
    
    public Subscription(@JsonProperty("billing_cycle_day") Double billingCycleDay, @JsonProperty("created_at") OffsetDateTime createdAt, @JsonProperty("customer") Customer customer, @JsonProperty("end_date") OffsetDateTime endDate, @JsonProperty("fixed_fee_quantity_schedule") SubscriptionFixedFeeQuantitySchedule[] fixedFeeQuantitySchedule, @JsonProperty("id") String id, @JsonProperty("metadata") SubscriptionMetadata metadata, @JsonProperty("plan") Plan plan, @JsonProperty("start_date") OffsetDateTime startDate, @JsonProperty("status") SubscriptionStatus status) {
        this.billingCycleDay = billingCycleDay;
        this.createdAt = createdAt;
        this.customer = customer;
        this.endDate = endDate;
        this.fixedFeeQuantitySchedule = fixedFeeQuantitySchedule;
        this.id = id;
        this.metadata = metadata;
        this.plan = plan;
        this.startDate = startDate;
        this.status = status;
  }
}
